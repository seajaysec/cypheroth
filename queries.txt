All users with SPN in Domain Admin group, with enabled status and unconstrained delegation status displayed;MATCH (u:User {hasspn:true}) MATCH (g:Group {name:'DOMAIN ADMINS@$DOMAIN'}) RETURN u.name AS Username,u.displayname AS DisplayName,u.enabled AS Enabled,u.unconstraineddelegation AS UnconstrainedDelegation;spnDATargets.csv
Kerberoastable users sorted by total machine admin count;MATCH (u:User {hasspn:true}) OPTIONAL MATCH (u)-[:AdminTo]->(c1:Computer) OPTIONAL MATCH (u)-[:MemberOf*1..]->(:Group)-[:AdminTo]->(c2:Computer) WITH u,COLLECT(c1) + COLLECT(c2) AS tempVar UNWIND tempVar AS comps RETURN u.name,u.displayname,u.domain,u.description,u.highvalue,COUNT(DISTINCT(comps)) ORDER BY COUNT(DISTINCT(comps)) DESC;DomainUserRDPComputers.csv
Kerberoastable users and computers where they are admins;OPTIONAL MATCH (u1:User) WHERE u1.hasspn=true OPTIONAL MATCH (u1)-[r:AdminTo]->(c:Computer) RETURN u1.name AS KerberoastableUser,c.name AS LocalAdminComputerName,c.operatingsystem AS OS,c.description AS Description,c.highvalue AS HighValue, c.unconstraineddelegation AS UnconstrainedDelegation;kerbUsersAdminComputers.csv
Users with paths to High Value groups;MATCH (u:User) MATCH (g:Group {highvalue:true}) MATCH p = shortestPath((u:User)-[r:AddMember|AdminTo|AllExtendedRights|AllowedToDelegate|Contains|ExecuteDCOM|ForceChangePassword|GenericAll|GenericWrite|GpLink|HasSession|MemberOf|Owns|ReadLAPSPassword|TrustedBy|WriteDacl|WriteOwner|GetChanges|GetChangesAll*1..]->(g)) RETURN DISTINCT(u.name) AS UserName,u.enabled as Enabled,count(p) as PathCount order by u.name;UserHVGroupPaths.csv
All computers that members of the Domain Users group can RDP to;match p=(g:Group)-[:CanRDP]->(c:Computer) where g.name STARTS WITH 'DOMAIN USERS' return c.name,c.domain,c.operatingsystem,c.highvalue,c.haslaps;DomainUserRDPComputers.csv
Users that are not AdminCount 1, have generic all, and no local admin;MATCH (u:User)-[:GenericAll]->(c:Computer) WHERE NOT u.admincount AND NOT (u)-[:AdminTo]->(c) RETURN u.name,u.displayname,c.name,c.highvalue;specialAdmins.csv
Users that are admin on 1+ machines, sorted by admin count;MATCH (U:User)-[r:MemberOf|:AdminTo*1..]->(C:Computer) WITH U.name as n, COUNT(DISTINCT(C)) as c WHERE c>0 RETURN n AS UserName, c ORDER BY c DESC;UserAdminCount.csv
What permissions does Everyone/Authenticated users/Domain users/Domain computers have;MATCH p=(m:Group)- [r:AddMember|AdminTo|AllExtendedRights|AllowedToDelegate|CanRDP|Contains|ExecuteDCOM|ForceChangePassword|GenericAll|GenericWrite|GetChanges|GetChangesAll|HasSession|Owns|ReadLAPSPassword|SQLAdmin|TrustedBy|WriteDACL|WriteOwner|AddAllowedToAct|AllowedToAct]->(t) WHERE m.objectsid ENDS WITH '-513' OR m.objectsid ENDS WITH '-515' OR m.objectsid ENDS WITH 'S-1-5-11' OR m.objectsid ENDS WITH 'S-1-1-0' RETURN m.name,TYPE(r),t.name,t.enabled;interestingPermissions.csv
Every computer account that has local admin rights on other computers;MATCH (c1:Computer) OPTIONAL MATCH (c1)-[:AdminTo]->(c2:Computer) OPTIONAL MATCH (c1)-[:MemberOf*1..]->(:Group)-[:AdminTo]->(c3:Computer) WITH COLLECT(c2) + COLLECT(c3) AS tempVar,c1 UNWIND tempVar AS computers RETURN c1.name AS Owner,computers.name AS Ownee;compOwners.csv
Find which domain Groups are Admins to what computers;MATCH (g:Group) OPTIONAL MATCH (g)-[:AdminTo]->(c1:Computer) OPTIONAL MATCH (g)-[:MemberOf*1..]->(:Group)-[:AdminTo]->(c2:Computer) WITH g, COLLECT(c1) + COLLECT(c2) AS tempVar UNWIND tempVar AS computers RETURN g.name,g.highvalue,computers.name,computers.highvalue;groupsAdminningComputers.csv
Computers where users which can Return, if they belong to adm or svr accounts;MATCH (c:Computer) MATCH (n:User)-[r:MemberOf]->(g:Group)  WHERE g.name = 'DOMAIN ADMINS@$DOMAIN' optional match (g:Group)-[:CanRDP]->(c) OPTIONAL MATCH (u1:User)-[:CanRDP]->(c) where u1.enabled = true and u1.name contains 'ADM' OR u1.name contains 'SVR' OPTIONAL MATCH (u2:User)-[:MemberOf*1..]->(:Group)-[:CanRDP]->(c) where u2.enabled = true and u2.name contains 'ADM' OR u2.name contains 'SVR' WITH COLLECT(u1) + COLLECT(u2) + collect(n) as tempVar,c UNWIND tempVar as users RETURN c.name AS ComputerName,COLLECT(DISTINCT(users.name)) as UserNames,count(DISTINCT(users.name)) AS UserCount ORDER BY UserCount desc;ReturnUserComps.csv
Computer names where each domain user has derivative Admin privileges to;MATCH (u:User)-[:MemberOf*1..]->(:Group)-[:AdminTo]->(c:Computer) RETURN DISTINCT(c.name) AS COMPUTER, u.name AS USER ORDER BY u.name;unrolledUserAdminPrivs.csv
Computers with Admins;MATCH (n)-[r:AdminTo]->(c:Computer) WITH COLLECT(c.name) as compsWithAdmins MATCH (c2:Computer) WHERE c2.name in compsWithAdmins RETURN c2.name ORDER BY c2.name ASC;compsWithAdmins.csv
Computers without Admins;MATCH (n)-[r:AdminTo]->(c:Computer) WITH COLLECT(c.name) as compsWithAdmins MATCH (c2:Computer) WHERE NOT c2.name in compsWithAdmins RETURN c2.name ORDER BY c2.name ASC;compsWithoutAdmins.csv
Groups with Computers and Admins;MATCH (c:Computer)-[r:MemberOf*1..]->(g:Group) WITH g MATCH (u:User)-[r:MemberOf*1..]->(g) RETURN DISTINCT(g.name) as Name, g.domain AS Domain, g.highvalue AS HighValue, g.objectsid AS SID, g.description AS Description, g.admincount AS AdminCount;GroupsWithCompsAndAdmins.csv
Group Admin Info;MATCH (g:Group) WITH g OPTIONAL MATCH (g)-[r:AdminTo]->(c1:Computer) WITH g,COUNT(c1) as explicitAdmins OPTIONAL MATCH (g)-[r:MemberOf*1..]->(a:Group)-[r2:AdminTo]->(c2:Computer) WITH g,explicitAdmins,COUNT(DISTINCT(c2)) as unrolledAdmins RETURN g.name AS Name,explicitAdmins,unrolledAdmins, explicitAdmins + unrolledAdmins as totalAdmins ORDER BY totalAdmins DESC;GroupAdminInfo.csv
Full User Property List;MATCH(u: User) SET u.llInt = coalesce(u.lastlogon,"1") SET u.lldInt = coalesce(u.lldate,"1") SET u.lltsInt = coalesce(u.lastlogontimestamp,"1") SET u.pwdlsInt = coalesce(u.pwdlastset,"1") RETURN u.name AS UserName, u.displayname AS DisplayName, u.domain AS Domain, u.enabled AS Enabled, u.highvalue AS HighValue, u.objectsid AS SID , u.description AS Description, u.title AS Title, u.email as Email, datetime({epochSeconds:toInteger(u.llInt)}) AS LastLogon, datetime({epochSeconds:toInteger(u.lldInt)}) AS LLDate, datetime({epochSeconds:toInteger(u.lltsInt)}) AS LLTimeStamp, datetime({epochSeconds:toInteger(u.pwdlsInt)}) AS PasswordLastSet, u.owned AS Owned, u.sensitive AS Sensitive, u.admincount AS AdminCount, u.hasspn AS HasSPN, u.unconstraineddelegation AS UnconstrainedDelegation, u.dontreqpreauth AS DontReqPreAuth, u.passwordnotreqd AS PasswordNotRequired, u.homedirectory AS HomeDirectory, u.serviceprincipalnames AS ServicePrincipalNames;AllUserProps.csv
Full Computer Property List;MATCH (c:Computer) SET c.llInt = coalesce(c.lastlogon,"1") SET c.lltsInt = coalesce(c.lastlogontimestamp,"1") SET c.pwdlsInt = coalesce(c.pwdlastset,"1") RETURN c.name AS ComputerName, c.operatingsystem AS OperatingSystem, c.domain AS Domain, c.enabled AS Enabled, c.highvalue AS HighValue, c.objectsid AS SID, c.description AS Description, datetime({epochSeconds:toInteger(c.llInt)}) AS LastLogon, datetime({epochSeconds:toInteger(c.lltsInt)}) AS LLTimeStamp, datetime({epochSeconds:toInteger(c.pwdlsInt)}) AS PasswordLastSet, c.owned AS Owned, c.haslaps AS HasLAPS, c.unconstraineddelegation AS UnconstrainedDelegation, c.allowedtodelegate AS AllowedToDelegate, c.serviceprincipalnames AS ServicePrincipalNames;AllCompProps.csv
Full Domain Property List;MATCH(d:Domain) RETURN d.name AS Name, d.domain AS Domain, d.functionallevel AS FunctionalLevel, d.highvalue AS HighValue, d.objectsid AS SID;AllDomProps.csv
Full OU Property List;MATCH(ou:OU) RETURN ou.name AS OU, ou.domain AS Domain, ou.highvalue AS HighValue, ou.guid AS GUID, ou.description AS Description, ou.blocksinheritance AS BlockInheritance;AllOUProps.csv
Full GPO Property List;MATCH(gpo:GPO) RETURN gpo.name AS GPO, gpo.domain AS Domain, gpo.highvalue AS HighValue, gpo.guid AS GUID, gpo.gpcpath AS GPC_Path;AllGPOProps.csv
Full Group Property List;MATCH(g:Group) RETURN g.name AS Name, g.domain AS Domain, g.highvalue AS HighValue, g.objectsid AS SID, g.description AS Description, g.admincount AS AdminCount;AllGroupProps.csv
